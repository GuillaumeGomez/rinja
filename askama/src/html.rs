// The file is shared across many crates, not all have this feature.
// If they don't then the tests won't be compiled in, but that's OK, because they are executed at
// least in the crate `askama`. There's no need to run the test multiple times.
#![allow(unexpected_cfgs)]

use core::{fmt, str};

#[allow(unused)]
pub(crate) fn write_escaped_str(mut dest: impl fmt::Write, src: &str) -> fmt::Result {
    // This implementation reads one byte after another.
    // It's not very fast, but should work well enough until portable SIMD gets stabilized.

    let mut escaped_buf = ESCAPED_BUF_INIT;
    let mut last = 0;

    for (index, byte) in src.bytes().enumerate() {
        if let Some(escaped) = get_escaped(byte) {
            [escaped_buf[2], escaped_buf[3]] = escaped;
            write_str_if_nonempty(&mut dest, &src[last..index])?;
            // SAFETY: the content of `escaped_buf` is pure ASCII
            dest.write_str(unsafe { str::from_utf8_unchecked(&escaped_buf[..ESCAPED_BUF_LEN]) })?;
            last = index + 1;
        }
    }
    write_str_if_nonempty(&mut dest, &src[last..])
}

#[allow(unused)]
pub(crate) fn write_escaped_char(mut dest: impl fmt::Write, c: char) -> fmt::Result {
    if !c.is_ascii() {
        dest.write_char(c)
    } else if let Some(escaped) = get_escaped(c as u8) {
        let mut escaped_buf = ESCAPED_BUF_INIT;
        [escaped_buf[2], escaped_buf[3]] = escaped;
        // SAFETY: the content of `escaped_buf` is pure ASCII
        dest.write_str(unsafe { str::from_utf8_unchecked(&escaped_buf[..ESCAPED_BUF_LEN]) })
    } else {
        // RATIONALE: `write_char(c)` gets optimized if it is known that `c.is_ascii()`
        dest.write_char(c)
    }
}

/// Returns the decimal representation of the codepoint if the character needs HTML escaping.
#[inline]
fn get_escaped(byte: u8) -> Option<[u8; 2]> {
    match byte {
        MIN_CHAR..=MAX_CHAR => Some(TABLE.0[(byte - MIN_CHAR) as usize]?.to_bytes()),
        _ => None,
    }
}

#[inline(always)]
fn write_str_if_nonempty(output: &mut impl fmt::Write, input: &str) -> fmt::Result {
    if !input.is_empty() {
        output.write_str(input)
    } else {
        Ok(())
    }
}

/// List of characters that need HTML escaping, not necessarily in ordinal order.
const CHARS: &[u8] = br#""&'<>"#;

/// The character with the lowest codepoint that needs HTML escaping.
const MIN_CHAR: u8 = {
    let mut v = u8::MAX;
    let mut i = 0;
    while i < CHARS.len() {
        if v > CHARS[i] {
            v = CHARS[i];
        }
        i += 1;
    }
    v
};

/// The character with the highest codepoint that needs HTML escaping.
const MAX_CHAR: u8 = {
    let mut v = u8::MIN;
    let mut i = 0;
    while i < CHARS.len() {
        if v < CHARS[i] {
            v = CHARS[i];
        }
        i += 1;
    }
    v
};

/// Number of codepoints between the lowest and highest character that needs escaping, incl.
const CHAR_RANGE: usize = (MAX_CHAR - MIN_CHAR + 1) as usize;

#[repr(align(64))]
struct Table([Option<Digits>; CHAR_RANGE]);

/// For characters that need HTML escaping, the codepoint is formatted as decimal digits,
/// otherwise `b"\0\0"`. Starting at [`MIN_CHAR`].
const TABLE: &Table = &{
    let mut table = Table([None; CHAR_RANGE]);
    let mut i = 0;
    while i < CHARS.len() {
        let c = CHARS[i];
        table.0[(c - MIN_CHAR) as usize] = Some(Digits::new(c));
        i += 1;
    }
    table
};

// RATIONALE: llvm generates better code if the buffer is register sized
const ESCAPED_BUF_INIT: [u8; 8] = *b"&#__;\0\0\0";
const ESCAPED_BUF_LEN: usize = b"&#__;".len();

/// All possible decimal representations of codepoints that need escaping in HTML / XML.
///
/// Using this type instead of e.g. `Option<NonZeroU16>` allows rustc to select any and all of the
/// 65,531 unused representations of this type as niche, which can can help speeding up the
/// generated byte code. If not all needed representations were present, then the `TABLE` definition
/// would fail to compile.
#[derive(Debug, Clone, Copy)]
#[repr(u16)]
enum Digits {
    /// `'"'`
    V34 = u16::from_ne_bytes(*b"34"),
    /// `'&'`
    V38 = u16::from_ne_bytes(*b"38"),
    /// `'\''`
    V39 = u16::from_ne_bytes(*b"39"),
    /// `'<'`
    V60 = u16::from_ne_bytes(*b"60"),
    /// `'>'`
    V62 = u16::from_ne_bytes(*b"62"),
}

impl Digits {
    #[inline]
    const fn to_bytes(self) -> [u8; 2] {
        (self as u16).to_ne_bytes()
    }

    const fn new(v: u8) -> Self {
        match v {
            34 => Self::V34,
            38 => Self::V38,
            39 => Self::V39,
            60 => Self::V60,
            62 => Self::V62,
            _ => panic!(),
        }
    }
}

#[test]
#[cfg(feature = "alloc")]
fn test_simple_html_string_escaping() {
    extern crate alloc;

    let mut buf = alloc::string::String::new();
    write_escaped_str(&mut buf, "<script>").unwrap();
    assert_eq!(buf, "&#60;script&#62;");

    buf.clear();
    write_escaped_str(&mut buf, "s<crip>t").unwrap();
    assert_eq!(buf, "s&#60;crip&#62;t");

    buf.clear();
    write_escaped_str(&mut buf, "s<cripcripcripcripcripcripcripcripcripcrip>t").unwrap();
    assert_eq!(buf, "s&#60;cripcripcripcripcripcripcripcripcripcrip&#62;t");
}
